#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: InGameLevelEditor

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "InGameLevelEditor_structs.hpp"


namespace SDK
{

// Class InGameLevelEditor.IGLE_ActionBufferObject
// 0x0008 (0x0030 - 0x0028)
class UIGLE_ActionBufferObject : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetFriendlyActionName(class FString* OutName);
	void Initialize();
	void RedoAction();
	void UndoAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IGLE_ActionBufferObject">();
	}
	static class UIGLE_ActionBufferObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIGLE_ActionBufferObject>();
	}
};
static_assert(alignof(UIGLE_ActionBufferObject) == 0x000008, "Wrong alignment on UIGLE_ActionBufferObject");
static_assert(sizeof(UIGLE_ActionBufferObject) == 0x000030, "Wrong size on UIGLE_ActionBufferObject");

// Class InGameLevelEditor.IGLE_AsyncRegisterPlacables
// 0x0030 (0x0060 - 0x0030)
class UIGLE_AsyncRegisterPlacables final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnPlacablesRegistered;                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UIGLE_AsyncRegisterPlacables* AsyncRegisterPlacables(const class UObject* WorldContextObject, const TArray<class FString>& ContentPaths, bool DeferDestruction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IGLE_AsyncRegisterPlacables">();
	}
	static class UIGLE_AsyncRegisterPlacables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIGLE_AsyncRegisterPlacables>();
	}
};
static_assert(alignof(UIGLE_AsyncRegisterPlacables) == 0x000008, "Wrong alignment on UIGLE_AsyncRegisterPlacables");
static_assert(sizeof(UIGLE_AsyncRegisterPlacables) == 0x000060, "Wrong size on UIGLE_AsyncRegisterPlacables");
static_assert(offsetof(UIGLE_AsyncRegisterPlacables, OnPlacablesRegistered) == 0x000030, "Member 'UIGLE_AsyncRegisterPlacables::OnPlacablesRegistered' has a wrong offset!");

// Class InGameLevelEditor.IGLE_FL
// 0x0000 (0x0028 - 0x0028)
class UIGLE_FL final : public UBlueprintFunctionLibrary
{
public:
	static struct FIGLELevelSave IGLE_BytesToLevelSave(const TArray<uint8>& LevelSaveBytes);
	static struct FTransform IGLE_BytesToTransform(const TArray<uint8>& Bytes);
	static void IGLE_CallInitializeForActionBufferObject(class UIGLE_ActionBufferObject* ActionBufferObject);
	static void IGLE_CallRedoForActionBufferObject(class UIGLE_ActionBufferObject* ActionBufferObject);
	static void IGLE_CallUndoForActionBufferObject(class UIGLE_ActionBufferObject* ActionBufferObject);
	static class FString IGLE_ClassToString(class UClass* Class_0);
	static void IGLE_CreateDir(const class FString& RelativeGameDirectory);
	static bool IGLE_CreatePlacableSave(class AActor* PlacableActorTarget, struct FIGLEPlacableSave* OutSave);
	static struct FRotator IGLE_DeltaRotator(const struct FRotator& A, const struct FRotator& B);
	static void IGLE_DeprojectScreenToWorld(const struct FVector2D& RelativeViewportPos, const struct FBox2D& Viewport, const struct FMatrix& ViewMatrix, const struct FMatrix& ProjectionMatrix, struct FVector* WorldPosition, struct FVector* WorldDirection);
	static void IGLE_DeserializeObject(class UObject* Object, const TArray<uint8>& Bytes);
	static class AActor* IGLE_GetActorReference(class UObject* WorldContextObject, const struct FIGLEActorReference& Reference);
	static TArray<class FString> IGLE_GetAllSubdirectories(const class FString& RelativeGameDirectory);
	static struct FBox2D IGLE_GetConstrainedViewRectangle(class APlayerController* PlayerController);
	static TArray<class FString> IGLE_GetFilesWithExtension(const class FString& RelativeGameDirectory, const class FString& Extension);
	static bool IGLE_IsObjectTransactionalAndTransient(const class UObject* Target);
	static TArray<uint8> IGLE_LevelSaveToBytes(const struct FIGLELevelSave& LevelSave);
	static class AActor* IGLE_LoadPlacableSave(class UObject* WorldContextObject, const struct FIGLEPlacableSave& SaveToLoad);
	static bool IGLE_MakeActorReference(class AActor* Actor, struct FIGLEActorReference* Reference);
	static struct FMatrix IGLE_MakeCustomProjectionMatrix(const struct FVector2D& ViewportSize, float FOV, float NearPlane, float FarPlane, bool InverseZMatrix, bool NoFarPlane);
	static struct FRotator IGLE_MultiplyRotator(const struct FRotator& A, const struct FRotator& B);
	static ECollisionChannel IGLE_ObjectTypeQueryToCollisionChannel(EObjectTypeQuery ObjectTypeQuery);
	static void IGLE_ProjectWorldToScreen(const struct FVector& WorldPos, const struct FBox2D& Viewport, const struct FMatrix& ViewMatrix, const struct FMatrix& ProjectionMatrix, struct FVector2D* ResultingScreenPos);
	static int64 IGLE_RandomInt64();
	static bool IGLE_ReadBytesFromFile(const class FString& AbsoluteLevelDirectory, TArray<uint8>* Bytes);
	static TArray<uint8> IGLE_SerializeObject(class UObject* Object);
	static void IGLE_SetCullingEnabledForActor(class AActor* Actor, bool EnableCulling);
	static void IGLE_SetRenderViewport(bool ShouldRender);
	static struct FQuat IGLE_Slerp(const struct FQuat& A, const struct FQuat& B, float Alpha);
	static void IGLE_SortStringArrayBySimilarity(const class FString& base, const TArray<class FString>& InputArray, TArray<struct FStringFloatPair>* OutputArray, bool IgnoreCase);
	static class UClass* IGLE_StringToClass(const class FString& String);
	static uint8 IGLE_StringToEnum(const class FString& String, TSoftObjectPtr<class UUserDefinedEnum> EnumClass);
	static bool IGLE_SweepActorWithWorld(class AActor* Target, ETraceTypeQuery TraceChannel, const struct FVector& Start, const struct FVector& End, TArray<struct FHitResult>* OutHits, class UPrimitiveComponent* OverrideComponent);
	static bool IGLE_TraceConvex(class UObject* WorldContextObject, const TArray<struct FVector>& Verticies, const struct FTransform& ShapeTransfom, ETraceTypeQuery TraceChannel, const struct FVector& Start, const struct FVector& End, const TArray<class AActor*>& ActorsToIgnore, TArray<struct FHitResult>* OutHits);
	static ECollisionChannel IGLE_TraceTypeQueryToCollisionChannel(ETraceTypeQuery TraceTypeQuery);
	static TArray<uint8> IGLE_TransformToBytes(const struct FTransform& Transform);
	static void IGLE_WriteBytesToFile(const class FString& RelativeGameDirectory, const TArray<uint8>& Bytes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IGLE_FL">();
	}
	static class UIGLE_FL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIGLE_FL>();
	}
};
static_assert(alignof(UIGLE_FL) == 0x000008, "Wrong alignment on UIGLE_FL");
static_assert(sizeof(UIGLE_FL) == 0x000028, "Wrong size on UIGLE_FL");

// Class InGameLevelEditor.IGLE_InterfaceComponent
// 0x0098 (0x0138 - 0x00A0)
class UIGLE_InterfaceComponent final : public UActorComponent
{
public:
	class FString                                 PlacableName;                                      // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlacableDescription;                               // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlacableCategory;                                  // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              PlacableIcon;                                      // 0x00D0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FIGLEProperty>                  Properties;                                        // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPropertyValueChanged;                            // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          CallOnPropertyChangedOnLoad;                       // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ActorID;                                           // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RuntimePlacableName;                               // 0x0128(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CallOnPropertyValueChanged(const class FString& PropertyName);
	bool GetPropertyByName(const class FString& PropertyName, struct FIGLEProperty* Property);
	bool GetPropertyByValueObject(class UIGLE_PropertyValueObject* PropertyValueObject, struct FIGLEProperty* Property);
	bool GetPropertyValueByName(const class FString& PropertyName, class UIGLE_PropertyValueObject** Value);
	void OnOwnerDestroyed(class AActor* Owner);
	void SetRuntimeName(const class FString& NewRuntimeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IGLE_InterfaceComponent">();
	}
	static class UIGLE_InterfaceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIGLE_InterfaceComponent>();
	}
};
static_assert(alignof(UIGLE_InterfaceComponent) == 0x000008, "Wrong alignment on UIGLE_InterfaceComponent");
static_assert(sizeof(UIGLE_InterfaceComponent) == 0x000138, "Wrong size on UIGLE_InterfaceComponent");
static_assert(offsetof(UIGLE_InterfaceComponent, PlacableName) == 0x0000A0, "Member 'UIGLE_InterfaceComponent::PlacableName' has a wrong offset!");
static_assert(offsetof(UIGLE_InterfaceComponent, PlacableDescription) == 0x0000B0, "Member 'UIGLE_InterfaceComponent::PlacableDescription' has a wrong offset!");
static_assert(offsetof(UIGLE_InterfaceComponent, PlacableCategory) == 0x0000C0, "Member 'UIGLE_InterfaceComponent::PlacableCategory' has a wrong offset!");
static_assert(offsetof(UIGLE_InterfaceComponent, PlacableIcon) == 0x0000D0, "Member 'UIGLE_InterfaceComponent::PlacableIcon' has a wrong offset!");
static_assert(offsetof(UIGLE_InterfaceComponent, Properties) == 0x0000F8, "Member 'UIGLE_InterfaceComponent::Properties' has a wrong offset!");
static_assert(offsetof(UIGLE_InterfaceComponent, OnPropertyValueChanged) == 0x000108, "Member 'UIGLE_InterfaceComponent::OnPropertyValueChanged' has a wrong offset!");
static_assert(offsetof(UIGLE_InterfaceComponent, CallOnPropertyChangedOnLoad) == 0x000118, "Member 'UIGLE_InterfaceComponent::CallOnPropertyChangedOnLoad' has a wrong offset!");
static_assert(offsetof(UIGLE_InterfaceComponent, ActorID) == 0x000120, "Member 'UIGLE_InterfaceComponent::ActorID' has a wrong offset!");
static_assert(offsetof(UIGLE_InterfaceComponent, RuntimePlacableName) == 0x000128, "Member 'UIGLE_InterfaceComponent::RuntimePlacableName' has a wrong offset!");

// Class InGameLevelEditor.IGLE_PropertyValueObject
// 0x0000 (0x0028 - 0x0028)
class UIGLE_PropertyValueObject : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IGLE_PropertyValueObject">();
	}
	static class UIGLE_PropertyValueObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIGLE_PropertyValueObject>();
	}
};
static_assert(alignof(UIGLE_PropertyValueObject) == 0x000008, "Wrong alignment on UIGLE_PropertyValueObject");
static_assert(sizeof(UIGLE_PropertyValueObject) == 0x000028, "Wrong size on UIGLE_PropertyValueObject");

// Class InGameLevelEditor.IGLE_RuntimeSubsystem
// 0x0078 (0x00A8 - 0x0030)
class UIGLE_RuntimeSubsystem final : public UGameInstanceSubsystem
{
public:
	TSet<struct FIGLEPlacableActorInfo>           PlacableActorInfoSet;                              // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsInLevelEditorMode;                               // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlacablePlacedInEditor;                          // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlacableDeletedInEditor;                         // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void RegisterPlacableActorInfo(const struct FIGLEPlacableActorInfo& Info);
	void RegisterPlacableActorInfoFromClasses(const TArray<class FString>& ContentPaths, TArray<class AActor*>* TransientActors, bool DeferDestruction);
	void RegisterPlacableActorInfoFromDataTable(class UDataTable* DataTable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IGLE_RuntimeSubsystem">();
	}
	static class UIGLE_RuntimeSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIGLE_RuntimeSubsystem>();
	}
};
static_assert(alignof(UIGLE_RuntimeSubsystem) == 0x000008, "Wrong alignment on UIGLE_RuntimeSubsystem");
static_assert(sizeof(UIGLE_RuntimeSubsystem) == 0x0000A8, "Wrong size on UIGLE_RuntimeSubsystem");
static_assert(offsetof(UIGLE_RuntimeSubsystem, PlacableActorInfoSet) == 0x000030, "Member 'UIGLE_RuntimeSubsystem::PlacableActorInfoSet' has a wrong offset!");
static_assert(offsetof(UIGLE_RuntimeSubsystem, IsInLevelEditorMode) == 0x000080, "Member 'UIGLE_RuntimeSubsystem::IsInLevelEditorMode' has a wrong offset!");
static_assert(offsetof(UIGLE_RuntimeSubsystem, OnPlacablePlacedInEditor) == 0x000088, "Member 'UIGLE_RuntimeSubsystem::OnPlacablePlacedInEditor' has a wrong offset!");
static_assert(offsetof(UIGLE_RuntimeSubsystem, OnPlacableDeletedInEditor) == 0x000098, "Member 'UIGLE_RuntimeSubsystem::OnPlacableDeletedInEditor' has a wrong offset!");

}

